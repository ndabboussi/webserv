


# webserv

CGI = 
    The Common Gateway Interface, or CGI, is a set of standards that define how information is exchanged between the web server and a custom script.

    The CGI specs are currently maintained by the NCSA and NCSA defines CGI is as follows −

    The Common Gateway Interface, or CGI, is a standard for external gateway programs to interface with information servers such as HTTP servers.

    The current version is CGI/1.1 and CGI/1.2 is under progress.


Fonction	Utilité
fork()	Crée un nouveau processus (enfant) identique au parent. Utilisé pour lancer un CGI sans bloquer le serveur.
execve(path, argv, envp)	Remplace le processus courant par un nouveau programme. En CGI : tu exécutes php-cgi, python, etc.
waitpid(pid, &status, options)	Attends qu’un processus enfant se termine, pour récupérer son code retour et éviter les zombies.
kill(pid, sig)	Envoie un signal à un processus (ex: tuer un CGI trop long).
signal(sig, handler)	Associe un handler à un signal (ex: SIGCHLD pour nettoyer les processus enfants, SIGINT pour arrêter proprement ton serveur).



Feuille de route :
1. se renseigner sur les fichiers de config
2. parser fichier de config
    aa. verifier les brackets, le mot serveur
    a. verifier les erreurs (ex: deux serveurs ouverts sur le meme port)
    b. si dans l'init du serveur y a pas de root, checker si les chemins des locations sont abs et si fonctionnent
3. connecter le serveur avec le navigateur


METHODS
0 aucune
1 GET
2 POST
3 GET+POST
4 DELETE
5 GET+DELETE
6 POST+DELETE
7 GET+POST+DELETE

WEBSERVER: https://www.youtube.com/watch?v=9J1nJOivdyw
API: https://www.youtube.com/watch?v=ByGJQzlzxQg
https://www.youtube.com/watch?v=T0DmHRdtqY0 
Ports: https://www.youtube.com/watch?v=YSl6bordSh8
OSI: https://www.youtube.com/watch?v=26jazyc7VNk
HTTP responses: https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status 

NGINX/Apache: https://djangodeployment.com/2016/11/15/why-nginx-is-faster-than-apache-and-why-you-neednt-necessarily-care/

Socket: https://www.geeksforgeeks.org/cpp/socket-programming-in-cpp/ 
hearders Content-Type: https://www.geeksforgeeks.org/html/http-headers-content-type/ 

Epoll VS Select: https://devarea.com/linux-io-multiplexing-select-vs-poll-vs-epoll/



Tuto: https://hackmd.io/@fttranscendance/H1mLWxbr_#Les-mots-cl%C3%A9s-%C3%A0-impl%C3%A9menter-

http://ncona.com/2019/04/building-a-simple-server-with-cpp/





WebServer:
1. listens 
2. on a port 
3. for a request
4. send via a TRansport Protocol
5. return a response
6. through a ressource



1. Create a Socket

Your program asks the OS to create a socket:

Specify address family (AF_INET for IPv4, AF_INET6 for IPv6).

Specify type (SOCK_STREAM for TCP, SOCK_DGRAM for UDP).

2. Bind (Server Side)

If you are writing a server:

You bind the socket to an IP address + port (e.g. 0.0.0.0:80).

This means “listen for incoming connections on this port.”

3. Listen & Accept (Server Side)

For TCP:

The socket listens for incoming connections.

When a client connects, the OS gives you a new socket dedicated to that connection.

4. Connect (Client Side)

If you are writing a client:

You connect your socket to the server’s IP + port.

The OS establishes a connection (TCP handshake).

5. Send & Receive Data

Both client and server can now send data (send) and receive data (recv) through their sockets.

This is the actual communication channel.

6. Close

When done, both sides close their sockets.




Pour webserv: (1) bien comprendre et faire un parsing minimaliste du fichier de config, l idee c est de vraiment autorise juste le necessaire pour respecter le sujet et interdire tout le reste ->  se baser sur nginx (2) faire un serveur basique avec epoll. Pour une introduction au project + une comprehension du serveur et des codes d erreur de base [https://m4nnb3ll.medium.com/webserv-building-a-non-blocking-web-server-in-c-98-a-42-project-04c7365e4ec7]. Pour comprendre la programmation concurrentielle [https://www.youtube.com/watch?v=RlM9AfWf1WU ]. Sur epoll, le man avec le code de la base du serveur (attention a bien verifier ready to read ET ready to write dans la main loop, pas comme sur l exemple, on peut en parler plus tard) [https://man7.org/linux/man-pages/man7/epoll.7.html]. Pour epoll in depth [https://medium.com/@avocadi/what-is-epoll-9bbc74272f7c] et [https://copyconstruct.medium.com/the-method-to-epolls-madness-d9d2d6378642] + les flag pour epoll ctl [https://man7.org/linux/man-pages/man2/epoll_ctl.2.html].

Ensuite il faut comprendre (peut etre meme avant epoll) les sockets non bloquantes: debut [https://dev.to/vivekyadav200988/understanding-blocking-and-non-blocking-sockets-in-c-programming-a-comprehensive-guide-2ien],  le rapport entre epoll et non bloquant [https://eklitzke.org/blocking-io-nonblocking-io-and-epoll], [https://copyconstruct.medium.com/nonblocking-i-o-99948ad7c957] le reste ca va se repeter un peu. Ne pas laisser trop de document te bloquer, tu vas vite comprendre en pratiquant avec des exemples minimalistes + tu pourras construire dessus par la suite.

Ensuite pour les CGI: la rfc cgi [https://datatracker.ietf.org/doc/html/rfc3875], le wiki [https://en.wikipedia.org/wiki/Common_Gateway_Interface], explication plus clair [https://coolicehost.com/billing/knowledgebase/article/101/what-is-a-common-getaway-interface-cgi/] -> tu peux ajouter les cgi a la fin c est vrt pas le coeur du sujet, hesite pas a demander conseil sur comment les implementer, il va falloir fork pour avoir un child et exec le script

Pour le parsing des requetes HTPP: la rfc (!a ce que tout soit bien http1.1 la version c est important) [https://datatracker.ietf.org/doc/html/rfc9112],  [https://www.ionos.fr/digitalguide/hebergement/aspects-techniques/requete-http/], [https://dl.ebooksworld.ir/books/HTTP.The.Definitive.Guide.Brian.Totty.David.Gourley.OReilly.9781565925090.EBooksWorld.ir.pdf], [https://http.dev/] -> lit pas toutes la RFC juste les requetes et les reponses -> c est le format qui t interesse + keep in mind que vous allez gerer seulement GET POST et DELETE donc ca limite les choses + vous pouvez vous limiter au erreurs gerees dans le schema de aprsing de l article d introduciton que je t ai mis + haut ^

les Requests c est vraiment easy tu te limite aux headers absolument necessaires et tu recuperes toutes les infos correctement parser des requests donc c est chill, il faut juste bien structure ta gestion d erreur nous on a vraiment mis le maximum de choses dans le parsing pour eviter les erreurs apres coup / au milieu du server.

Attention il faut bien tout proteger en cas d erreur interne
D autres notions a bien comprendre c est les redirections et les index, tu peux rajouter l auto index a la fin mais ca doit etre gerer ! si t as besoin d aide tu demande
et aussi ca pour comprendre les sockets basiques au debut c est pas mal [https://www.geeksforgeeks.org/socket-programming-in-cpp/]


https://medium.com/from-the-scratch/http-server-what-do-you-need-to-know-to-build-a-simple-http-server-from-scratch-d1ef8945e4fa
SOCKETS
Programming with TCP/IP sockets

There are a few steps involved in using sockets:

    Create the socket
    Identify the socket
    On the server, wait for an incoming connection
    Send and receive messages
    Close the socket

|                 | **select()**                                       | **epoll()**                                             |
| --------------- | -------------------------------------------------- | ------------------------------------------------------- |
| **Principe**    | Fournit un `fd_set` au kernel à chaque appel       | Enregistre les FDs une seule fois (epoll\_ctl)          |
| **Complexité**  | O(n) à chaque appel (il faut scanner tous les FDs) | O(1) pour notifier uniquement ceux qui sont actifs      |
| **Performance** | OK pour < 1 000 connexions                         | Idéal pour des milliers de connexions                   |
| **Portabilité** | POSIX, fonctionne partout                          | Linux-only                                              |
| **Simplicité**  | Facile à coder                                     | Plus complexe (nécessite un epoll\_fd et un event loop) |


SELECT https://copyconstruct.medium.com/nonblocking-i-o-99948ad7c957
https://devarea.com/linux-io-multiplexing-select-vs-poll-vs-epoll/
int select(
   int nfds,
   fd_set *readfds,
   fd_set *writefds,
   fd_set *exceptfds,
   struct timeval *timeout
);

— the readfds descriptors are monitored to see if a read will not block (when bytes become available for reading or when encountering an EOF)
— the writefds descriptors are monitored to for when a write will not block.
— the exceptfds descriptors are monitored for exceptional conditions
The final argument is a timeout value, which specifies for how long the select system call will block:
— when the timeout is set to 0, select does not block but returns immediately after polling the file descriptors
— when timeout is set to NULL, select will block “forever”. When select blocks, the kernel can put the process to sleep until select returns. Select will block until 1) one or more descriptors specified in the three sets described above are ready or 2) the call is interrupted by a signal handler
— when timeout is set to a specific value, then select will block until 1) one or more descriptors specified in the three sets described above are ready or 2) the call is interrupted by a signal handler or 3) the amount of time specified by timeout has expired

EPOLL https://copyconstruct.medium.com/the-method-to-epolls-madness-d9d2d6378642

HTTP Responses: https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Messages#http_responses


// Stat est ton ami pour Content-Length. Utilise st_size puis stream le fichier en morceaux.

// HEAD : renvoie mêmes headers qu’un GET (même Content-Length) mais pas le body.

// Keep-Alive : si tu veux conserver la connexion, envoie Content-Length (ou chunked) ; 
//si tu préfères fermer à la fin, envoie Connection: close et ferme le fd.

// Fichiers volumineux : évite de charger tout en mémoire ;
//fais un read/send en boucle (comme ci-dessus).

// Transfer-Encoding: chunked : utile pour le streaming dynamique si tu ne peux pas connaître la taille. Implémentation plus complexe (exemples ci-dessus).

// Encodage & charset : pour text/* indique charset=utf-8 (utile pour navigateurs).

// Sécurité : fais attention aux chemins (..) dans request.path — normalise et refuse si hors racine.

// Allow header pour 405 (tu peux construire la chaîne depuis la config Location).

// Si tu veux, je peux :

// Adapter le sendResponse ci-dessus pour intégrer le mapping request.statusCode
//(si tu utilises d’autres codes spéciaux) ou pour inclure Allow: en cas de 405 à partir de ta config Location.

// Rédiger une version chunked si tu veux servir du streaming dynamique.

// Ajouter la gestion des Range requests (206 Partial Content) (un peu plus délicat mais faisable).

// Tu veux que j’ajoute l’une de ces options



Responses

1. determiner s'il y a une erreur
2. determiner s'il faut un body en fonction de la methode + creer body (a stocker qq part)
3. determiner le code d'erreur
4. lancer la creation du status line 
5. creation headers a append
6. append body
7. send response, store it


location header in response : https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.30


📦 Cas où tu dois renvoyer un body

200 OK
→ Réponse normale : tu rends le fichier demandé (GET), ou une confirmation de POST.
✅ Body attendu (HTML, JSON, fichier, etc.).

201 Created
→ Quand un POST a créé une ressource.
✅ Tu peux renvoyer dans le body soit un message de confirmation, soit la ressource nouvellement créée, soit rien (mais body possible).

4xx erreurs client (404 Not Found, 403 Forbidden, 400 Bad Request, 405 Method Not Allowed, etc.)
→ Les navigateurs s’attendent à recevoir une petite page HTML expliquant l’erreur.
✅ Body nécessaire (même juste une page par défaut).

5xx erreurs serveur (500 Internal Server Error, 501 Not Implemented, etc.)
→ Pareil que 4xx, body avec explication (souvent une page HTML d’erreur).
✅ Body nécessaire.

🚫 Cas où tu NE DOIS PAS renvoyer de body

204 No Content
→ Typiquement après un DELETE réussi.
❌ Interdit d’envoyer un body.
⚠️ Si tu mets Content-Length: 0, le navigateur comprend.

304 Not Modified (si jamais tu l’implémentes plus tard pour la mise en cache)
❌ Interdit d’envoyer un body.

1xx réponses informatives (100 Continue, 101 Switching Protocols)
❌ Pas de body.
-

NINA TO DO

//timeout

//redirection 300
//create redirect for directory if 301
// handle 300 and redirect to the right locatin
//301 faire la redirection vers le bon directory

//protect launchServer() and sendResponse() functions


https://www.garshol.priv.no/download/text/http-tut.html

CGI = https://www.ibm.com/docs/en/i/7.6.0?topic=programming-setting-up-cgi-programs
